<html>
   <head>
      <title>Escape from Death Castle</title>
      <style>
        body { margin: 0; background-color: black; }
        canvas {
          border: 2px solid #808080;
          background-color: black;
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translateX(-50%) translateY(-50%);
       }
      </style>
  </head>
  <body>
    <script src="js/three.js"></script>
    <script>
      class Room {
        constructor(scene, width, depth, height) {
          this.WIREFRAME_COLOUR = 0x808080;

          var geometry = new THREE.BoxGeometry(width, height, depth);
          var cube = this._buildShape(geometry, 0, 0);
          scene.add(cube);

          this.scene = scene;
          this.shape = cube;
          this.width = width;
          this.height = height;
          this.depth = depth;

          this.maxX = width/2;
          this.minX = -width/2;
          this.maxY = depth/2;
          this.minY = -depth/2;

          this.doors = [];
        }

        hitsWall(deltaX, deltaY) {
          if (this.doors.includes(this.maxY) && deltaY >= this.maxY - 1 && deltaX >= -.65 && deltaX <= .65)
            return false;

          if (this.doors.includes(this.minY) && deltaY <= this.minY + 1 && deltaX >= -.65 && deltaX <= .65)
            return false;

          if (this.doors.includes(this.maxX) && deltaX >= this.maxX - 1 && deltaY >= -.65 && deltaY <= .65)
            return false;

          if (this.doors.includes(this.minX) && deltaX <= this.minX + 1 && deltaY >= -.65 && deltaY <= .65)
            return false;

          return deltaX >= this.maxX - 1 ||
                 deltaX <= this.minX + 1 ||
                 deltaY >= this.maxY - 1||
                 deltaY <= this.minY + 1;
        }

        _addBrick(x, y, z, rotate) {
          var geometry = new THREE.BoxGeometry(.3, .1, 0);
          var brick = this._buildShape(geometry, x, z, y);
          if (rotate) {
            brick.rotation.x += Math.PI/2;
            brick.rotation.y += Math.PI/2;
            brick.rotation.z += Math.PI/2;
          }

          this.scene.add(brick);
        }

        _addDoor(x, z, rotate) {
          var door = new THREE.Group();

          // outer
          var curve = new THREE.EllipseCurve(0, 0 /*ax, ay*/, .75, .75 /* xRadius, yRadius */, 0, Math.PI /* aStartAngle, aEndAngle */, false);
          var points = curve.getSpacedPoints( 20 );
          var path = new THREE.Path();
          var geometry = path.createGeometry( points );
          var material = new THREE.LineBasicMaterial( { color : this.WIREFRAME_COLOUR } );
          var outer = new THREE.Line( geometry, material );
          door.add(outer);

          var lg1 = new THREE.Geometry();
          lg1.vertices.push(new THREE.Vector3(.75, -1.5, 0), new THREE.Vector3(.75, 0, 0));
          var l1 = new THREE.Line(lg1, material);
          door.add(l1);

          var lg2 = new THREE.Geometry();
          lg2.vertices.push(new THREE.Vector3(-.75, -1.5, 0), new THREE.Vector3(-.75, 0, 0));
          var l2 = new THREE.Line(lg2, material);
          door.add(l2);

          // inner
          curve = new THREE.EllipseCurve(0, 0 /*ax, ay*/, .65, .65 /* xRadius, yRadius */, 0, Math.PI /* aStartAngle, aEndAngle */, false);
          points = curve.getSpacedPoints( 20 );
          path = new THREE.Path();
          geometry = path.createGeometry( points );
          material = new THREE.LineBasicMaterial( { color : this.WIREFRAME_COLOUR } );
          var inner = new THREE.Line( geometry, material );
          door.add(inner);

          lg1 = new THREE.Geometry();
          lg1.vertices.push(new THREE.Vector3(.65, -1.5, 0), new THREE.Vector3(.65, 0, 0));
          l1 = new THREE.Line(lg1, material);
          door.add(l1);

          lg2 = new THREE.Geometry();
          lg2.vertices.push(new THREE.Vector3(-.65, -1.5, 0), new THREE.Vector3(-.65, 0, 0));
          l2 = new THREE.Line(lg2, material);
          door.add(l2);

          if (rotate)
            door.rotation.y += Math.PI/2;

          door.position.x += x;
          door.position.z += z;

          this.scene.add(door);
          this.doors.push(z);
        }

        _buildShape(geometry, x, z, y=0) {
          var edges = new THREE.EdgesGeometry(geometry);
          var material = new THREE.LineBasicMaterial({color: this.WIREFRAME_COLOUR});
          var shape = new THREE.LineSegments(edges, material);
          shape.position.x = x;
          shape.position.z = z;
          shape.position.y = y;
          return shape;
        }       
      }

      class EntranceHall extends Room {
        constructor(scene, width, depth, height) {
          super(scene, width, depth, height);

          this._addBricks(2, .3, this.minY);
          this._addBricks(-2, .8, this.minY);
          
          this._addBricks(1.6, .3, this.maxY);
          this._addBricks(-2.7, .1, this.maxY);
          
          this._addBricks2(2.3, .3, this.minX);
          this._addBricks2(-.2, 1.3, this.minX);
          this._addBricks2(-3.6, .1, this.minX);
          
          this._addBricks2(1.2, .8, this.maxX);
          this._addBricks2(-2.9, .1, this.maxX);

          this._addDoor(0, this.maxY);
          this._addDoor(0, this.minY);
          this._addDoor(this.minX, 0, true);
          this._addDoor(this.maxX, 0, true);
        }

        _addBricks(xOffset, yOffset, zOffset) {
          this._addBrick(0 + xOffset, 0 + yOffset, zOffset, false);
          this._addBrick(.6 + xOffset, 0 + yOffset, zOffset, false);
          this._addBrick(.9 + xOffset, 0 + yOffset, zOffset, false);
          
          this._addBrick(.15 + xOffset, -.1 + yOffset, zOffset, false);
          this._addBrick(.45 + xOffset, -.1 + yOffset, zOffset, false);
          this._addBrick(.75 + xOffset, -.1 + yOffset, zOffset, false);
          
          this._addBrick(0 + xOffset, -.2 + yOffset, zOffset, false);
          this._addBrick(.3 + xOffset, -.2 + yOffset, zOffset, false);
          this._addBrick(.6 + xOffset, -.2 + yOffset, zOffset, false);
        }

        _addBricks2(xOffset, yOffset, zOffset) {
          this._addBrick(zOffset, 0 + yOffset, 0 + xOffset, true);
          this._addBrick(zOffset, 0 + yOffset, .6 + xOffset, true);
          this._addBrick(zOffset, 0 + yOffset, .9 + xOffset, true);
          
          this._addBrick(zOffset, -.1 + yOffset, .15 + xOffset, true);
          this._addBrick(zOffset, -.1 + yOffset, .45 + xOffset, true);
          this._addBrick(zOffset, -.1 + yOffset, .75 + xOffset, true);
          
          this._addBrick(zOffset, -.2 + yOffset, 0 + xOffset, true);
          this._addBrick(zOffset, -.2 + yOffset, .3 + xOffset, true);
          this._addBrick(zOffset, -.2 + yOffset, .6 + xOffset, true);
        }
      }

      class Game {
        constructor(width, height) {
          this.counter = 1;
        
          this.width = width;
          this.height = height;
            
          this.scene = new THREE.Scene();
          
          this.camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
          this.camera.position.y = -.5;
          this.camera.rotation.y += Math.PI;

          this.renderer = new THREE.WebGLRenderer();
          this.renderer.setSize(width, height);
          document.body.appendChild(this.renderer.domElement);

          // define room
          var x = this.camera.position.x;
          var y = this.camera.position.y;
          this.room = new EntranceHall(this.scene, 10, 10, 3);

          // subscribe to input events
          var self = this;
          document.onkeydown = e => self._handleInput(self, e);
        }
        /*
        addPyramid(x, z) {
          var geometry = new THREE.Geometry();
          geometry.vertices.push(
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(1, 0, 1),
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(0.5, 1, 0.5));            
          geometry.faces.push(
            new THREE.Face3(0, 2, 1),
            new THREE.Face3(0, 3, 2),
            new THREE.Face3(1, 4, 0),
            new THREE.Face3(2, 4, 1),
            new THREE.Face3(3, 4, 2),
            new THREE.Face3(0, 4, 3));
          
          var pyramid = this._buildShape(geometry, x, z);
          pyramid.position.y = -0.5;
          this.scene.add(pyramid);
          return pyramid;
        }
        */

        gameLoop(refreshRateMs = 50) {
          setInterval(() => {
            this._render();
          }, refreshRateMs);
        }
        
        _render() {
          //requestAnimationFrame(sender._render(sender));
          this.renderer.render(this.scene, this.camera);
        }
        
        _getPosVector(d, theta) {
          var hyp = d;
          var opp = hyp * Math.sin(theta);
          var adj = hyp * Math.cos(theta);
          return new THREE.Vector2(opp, adj);
        }
      
        _handleInput(sender, e) {
          var theta = sender.camera.rotation.y - Math.PI;
          var pos = sender._getPosVector(.1, theta);

          switch(e.keyCode) {
            case 38: // up
              var deltaX = sender.camera.position.x + pos.x;
              var deltaY = sender.camera.position.z + pos.y;
              if (sender.room.hitsWall(deltaX, deltaY))
                return;

              sender.camera.position.x += pos.x;
              sender.camera.position.z += pos.y;
              break;
            case 40: // down
              var deltaX = sender.camera.position.x - pos.x;
              var deltaY = sender.camera.position.z - pos.y;
              if (sender.room.hitsWall(deltaX, deltaY))
                return;

              sender.camera.position.x -= pos.x;
              sender.camera.position.z -= pos.y;
              break;
            case 37: // left
              sender.camera.rotation.y += .1;
              break;
            case 39: // right
              sender.camera.rotation.y -= .1;
              break;  
          }
        }
      }
      
      var game = new Game(800, 600);
      game.gameLoop();
    </script>
   </body>
</html>