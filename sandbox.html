<html>
   <head>
      <title>Escape from Death Castle</title>
      <style>
        body { margin: 0; background-color: black; }
        canvas {
          border: 2px solid #808080;
          background-color: black;
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translateX(-50%) translateY(-50%);
       }
      </style>
  </head>
  <body>
    <script src="js/three.js"></script>
    <script>
      class Game {
        constructor(width, height) {
          this.LIGHT_GREEN = 0x808080;
          
          this.counter = 1;
        
          this.width = width;
          this.height = height;
            
          this.scene = new THREE.Scene();
          
          this.camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
          this.camera.position.z = -5;
          this.camera.rotation.y += Math.PI;

          this.renderer = new THREE.WebGLRenderer();
          this.renderer.setSize(width, height);
          document.body.appendChild(this.renderer.domElement);

          // define room
          var x = this.camera.position.x;
          var y = this.camera.position.z;
          this.addCube(x, y);
          // var key = this.addKey(x, y);
          var table = this.addTable(x, y)
          var chair = this.addChair(x, y)
          
          //this.scene.add( key );
          //this.axis = new THREE.Vector3(1,0, 0);

          // subscribe to input events
          var self = this;
          document.onkeydown = e => self._handleInput(self, e);
        }
        
        addCube(x, z) {
          var geometry = new THREE.BoxGeometry(10, 3, 10); // width, height, depth
          var cube = this._buildShape(geometry, x, z);
          cube.rotation.y += 2;
          this.scene.add(cube);
          return cube;
        }
        
        addPyramid(x, z) {
          var geometry = new THREE.Geometry();
          geometry.vertices.push(
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(1, 0, 1),
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(0.5, 1, 0.5));            
          geometry.faces.push(
            new THREE.Face3(0, 2, 1),
            new THREE.Face3(0, 3, 2),
            new THREE.Face3(1, 4, 0),
            new THREE.Face3(2, 4, 1),
            new THREE.Face3(3, 4, 2),
            new THREE.Face3(0, 4, 3));
          
          var pyramid = this._buildShape(geometry, x, z);
          pyramid.position.y = -0.5;
          this.scene.add(pyramid);
          return pyramid;
        }

        addTable(x, z) {
          var points = [];
          points.push( new THREE.Vector2( 0.05, -1.5 ));
          points.push( new THREE.Vector2( 0.1, -1.4 ));
          points.push( new THREE.Vector2( 0.1, -1.35 ));
          points.push( new THREE.Vector2( 0.05, -1.3 ));
          points.push( new THREE.Vector2( 0.15, -0.7 ));
          
          var legGeometry = new THREE.LatheGeometry( points)
          var leg1 = this._buildShape(legGeometry, x, z);
          var leg2 = this._buildShape(legGeometry, x+1.2, z);
          var leg3 = this._buildShape(legGeometry, x+1.2, z+2.2);
          var leg4 = this._buildShape(legGeometry, x, z+2.2);

          var tableGeometry1 = new THREE.BoxGeometry(1.6, 0.05, 2.6); // width, height, depth
          var tableGeometry2 = new THREE.BoxGeometry(1.8, 0.05, 2.8); // width, height, depth
          var cube1 = this._buildShape(tableGeometry1, x+0.6, z+1.1);
          var cube2 = this._buildShape(tableGeometry2, x+0.6, z+1.1);
          cube1.position.y = -0.675
          cube2.position.y = -0.625
          // cube.rotation.y += 2;
          var group = new THREE.Group();
          group.add( cube1 )
          group.add( cube2 )
          group.add( leg1 )
          group.add( leg2 )
          group.add( leg3 )
          group.add( leg4 )
          group.rotation.y += Math.PI / 4
          this.scene.add(group);
        }

        addChair(x, z) {
          var points = [];
          points.push( new THREE.Vector2( 0.025, -1.5 ));
          points.push( new THREE.Vector2( 0.05, -1.45 ));
          points.push( new THREE.Vector2( 0.05, -1.425 ));
          points.push( new THREE.Vector2( 0.025, -1.375 ));
          points.push( new THREE.Vector2( 0.075, -1.1 ));
          
          var legGeometry = new THREE.LatheGeometry( points)
          var leg1 = this._buildShape(legGeometry, x, z);
          var leg2 = this._buildShape(legGeometry, x+0.3, z);
          var leg3 = this._buildShape(legGeometry, x+0.3, z+0.3);
          var leg4 = this._buildShape(legGeometry, x, z+0.3);

          var chairseatGeometry1 = new THREE.BoxGeometry(0.45, 0.05, 0.45); // width, height, depth
          var cube1 = this._buildShape(chairseatGeometry1, x+0.15, z+0.15);

          var backShape = new THREE.Shape();
          backShape.moveTo(0,0);
          backShape.lineTo(0.225,0);
          backShape.lineTo(0.225,0.3);
          backShape.quadraticCurveTo(0.075, 0.3, 0.075, 0.75);
          backShape.quadraticCurveTo(0.225, 0.75, 0.225, 0.8125);
          backShape.quadraticCurveTo(0.225, 0.875, 0.075, 0.875);
          backShape.quadraticCurveTo(0.075, 1, 0, 1);
          backShape.quadraticCurveTo(-0.075, 1, -0.075, 0.875);
          backShape.quadraticCurveTo(-0.225, 0.875, -0.225, 0.8125);
          backShape.quadraticCurveTo(-0.225, 0.75, -0.075, 0.75);
          backShape.quadraticCurveTo(-0.075, 0.3, -0.225, 0.3);
          backShape.lineTo(-0.225,0);
          backShape.autoClose = true;
          
          var extrudeSettings = { amount: 0.05, steps: 1, bevelEnabled: false};
          var backGeometry = new THREE.ExtrudeGeometry( backShape, extrudeSettings );

          var back = this._buildShape(backGeometry, x+0.15, z-0.07);


          back.position.y = -1.05
          cube1.position.y = -1.075
          var group = new THREE.Group();
          group.add( cube1 )
          group.add( back )
          //group.add( cube2 )
          group.add( leg1 )
          group.add( leg2 )
          group.add( leg3 )
          group.add( leg4 )
          //group.rotation.y += Math.PI / 4
          this.scene.add(group);
        }


        addKey(x, z) {
          var ss = 0.4 // shape size
          var trackShape = new THREE.Shape();
          trackShape.moveTo( 0.1 * ss, 0.075  * ss);
          trackShape.lineTo( 0.4 * ss, 0.3 * ss );
          trackShape.lineTo( 0.4 * ss, 0.7 * ss );
          trackShape.lineTo( 0 * ss, 1 * ss );
          trackShape.lineTo( -0.4 * ss, 0.7 * ss );
          trackShape.lineTo( -0.4 * ss, 0.3 * ss );
          trackShape.lineTo( -0.1 * ss, 0.075 * ss );
          trackShape.lineTo( -0.1 * ss, -1.5 * ss );
          trackShape.lineTo( 0.1 * ss, -1.5 * ss );
          trackShape.lineTo( 0.1 * ss, -1.4 * ss );
          trackShape.lineTo( 0.4 * ss, -1.4 * ss );
          trackShape.lineTo( 0.4 * ss, -1 * ss );
          trackShape.lineTo( 0.1 * ss, -1 * ss );

          trackShape.autoClose = true;
          //var geometry = new THREE.ShapeBufferGeometry( trackShape );
          var extrudeSettings = {
            steps: 1,
            amount: 0.1 * ss,
            bevelEnabled: false,
            bevelThickness: 0.1,
            bevelSize: 0.1,
            bevelSegments: 1
          };

          var geometry = new THREE.ExtrudeGeometry( trackShape, extrudeSettings );

          //var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
          //var mesh = new THREE.Mesh( geometry, material ) ;
          var object = this._buildShape(geometry, x, z);
          //this.scene.add( mesh );
          //this.scene.add( object );
          return object
        }
        
        gameLoop(refreshRateMs = 50) {
          setInterval(() => {
            this._render();
            //this.group.rotateOnAxis(this.axis,0.01);
          }, refreshRateMs);
          
        }
        
        _render() {
          //requestAnimationFrame(sender._render(sender));
          this.renderer.render(this.scene, this.camera);
        }
        
        _buildShape(geometry, x, z) {
          var edges = new THREE.EdgesGeometry(geometry);
          var material = new THREE.LineBasicMaterial({color: this.LIGHT_GREEN});
          var shape = new THREE.LineSegments(edges, material);
          shape.position.x = x;
          shape.position.z = z;
          return shape;
        }
        
        _getPosVector(d, theta) {
          var hyp = d;
          var opp = hyp * Math.sin(theta);
          var adj = hyp * Math.cos(theta);
          return new THREE.Vector2(opp, adj);
        }
      
        _handleInput(sender, e) {
          var theta = sender.camera.rotation.y - Math.PI;
          var pos = sender._getPosVector(.1, theta);

          switch(e.keyCode) {
            case 38: // up
              if (sender.camera.position.x + pos.x >= 5 - 1 ||
                  sender.camera.position.x + pos.x <= -5 +1 ||
                  sender.camera.position.z + pos.y >= 0 - 1 ||
                  sender.camera.position.z + pos.y <= -10 + 1)
                return;

              sender.camera.position.x += pos.x;
              sender.camera.position.z += pos.y;
              break;
            case 40: // down
              if (sender.camera.position.x - pos.x >= 5 - 1 ||
                  sender.camera.position.x - pos.x <= -5 + 1 ||
                  sender.camera.position.z - pos.y >= 0 - 1 ||
                  sender.camera.position.z - pos.y <= -10 + 1)
                return;

              sender.camera.position.x -= pos.x;
              sender.camera.position.z -= pos.y;
              break;
            case 37: // left
              sender.camera.rotation.y += .1;
              break;
            case 39: // right
              sender.camera.rotation.y -= .1;
              break;  
          }
        }
      }
      
      var game = new Game(800, 600);
      game.gameLoop();
    </script>
   </body>
</html>